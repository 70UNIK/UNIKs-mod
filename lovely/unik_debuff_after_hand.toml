[manifest]
version = "0.0.1"
dump_lua = true
priority = 9999

### Debuff after hand, either for blind functionality after a hand is played, add to blind size or outright having it not score.

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''check_for_unlock({type = 'chip_score', chips = math.floor( SMODS.calculate_round_score() )})'''
position = 'after'
payload = '''
local nanny = tostring(number_format(math.floor(SMODS.calculate_round_score())))

-- -nan fix
if nanny ~= '-nan' then

    G.GAME.round_scores['hand'].amt = math.max(G.GAME.round_scores['hand'].amt,SMODS.calculate_round_score())
else
    G.GAME.round_scores['hand'].amt = math.huge
    G.GAME.round_scores.hand.amt = math.huge
    print(number_format(G.GAME.round_scores.hand.amt))
end
local checker = G.GAME.blind:unik_debuff_after_hand(poker_hands, scoring_hand,G.play.cards,false,SMODS.calculate_round_score())
local debuff_hand = false
local add_to_blind = 0
if checker and checker.debuff then
    debuff_hand = true
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function()
            if SMODS.hand_debuff_source then SMODS.hand_debuff_source:juice_up(0.3,0) else SMODS.juice_up_blind() end
            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()
                play_sound('tarot2', 0.76, 0.4);return true end}))
            play_sound('tarot2', 1, 0.4)
            return true
        end)
    }))
end
if checker and checker.add_to_blind then
    if nanny == '-nan' then
        add_to_blind = math.huge
    else
        add_to_blind = to_big(checker.add_to_blind)
    end
    
end
'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''        func = (function() play_sound('chips2');return true end)
        }))
    end'''
position = 'after'
payload = '''
if to_big(add_to_blind) > to_big(0) or add_to_blind == math.huge then
    if add_to_blind == math.huge then
        G.E_MANAGER:add_event(Event({
            trigger = 'ease',
            blocking = false,
            ref_table = G.GAME.blind,
            ref_value = 'chips',
            ease_to = math.huge,
            delay =  0.5,
            func = (function(t) return math.floor(t) end)
        }))
        G.E_MANAGER:add_event(Event({
            trigger = 'ease',
            blocking = false,
            ref_table = G.GAME.blind,
            ref_value = 'chip_text',
            ease_to = math.huge,
            delay =  0.5,
            func = (function(t) return math.floor(t) end)
        }))
    else
        G.E_MANAGER:add_event(Event({
            trigger = 'ease',
            blocking = false,
            ref_table = G.GAME.blind,
            ref_value = 'chips',
            ease_to = G.GAME.blind.chips + add_to_blind,
            delay =  0.5,
            func = (function(t) return math.floor(t) end)
        }))
        G.E_MANAGER:add_event(Event({
            trigger = 'ease',
            blocking = false,
            ref_table = G.GAME.blind,
            ref_value = 'chip_text',
            ease_to = G.GAME.blind.chips + add_to_blind,
            delay =  0.5,
            func = (function(t) return math.floor(t) end)
        }))
    end
end
G.E_MANAGER:add_event(Event({
    func = function()
        UNIK.railroad_suits()
        return true
    end
}))

if debuff_hand then
    play_area_status_text("Not Allowed!")

    SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, debuffed_hand = true})
end

'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind, now with bunco compat.
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'before'
payload = '''
if not debuff_hand and nanny ~= '-nan' and G.GAME.chips_text ~= '-nan' then
'''

### display the fake score before not allowing the hand and/or adding to blind part 2
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'after'
payload = '''
elseif not debuff_hand and nanny == '-nan' or G.GAME.chips_text == '-nan' then
 G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = (function() 
                    G.GAME.chips = math.huge
                    G.GAME.blind:calculate()
                
                return true end)
                }))
    
end
'''

### unik_afterplay
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true})'''
position = 'after'
payload = '''
G.GAME.blind:unik_after_play()
if G.GAME.blind_edition and G.GAME.blind_edition[G.GAME.blind_on_deck] and not reset and (G.GAME.blind and G.GAME.blind.name and G.GAME.blind.name ~= '') then
    local edi = G.P_BLIND_EDITIONS[G.GAME.blind_edition[G.GAME.blind_on_deck]]
    if edi.unik_after_play and edi.unik_after_play() and (type(edi.unik_after_play) == "function") then
        delay(0.4)
        edi:unik_after_play()
    end
end
'''
match_indent = true

### unik_afterplay
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if G.GAME.chips - G.GAME.blind.chips >= 0 then'''
position = 'at'
payload = '''if to_big(G.GAME.chips - G.GAME.blind.chips) >= to_big(0) then'''
match_indent = true