[manifest]
version = "0.0.1"
dump_lua = true
priority = 9999

### Debuff after hand, either for blind functionality after a hand is played, add to blind size or outright having it not score.

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''check_for_unlock({type = 'chip_score', chips = math.floor( SMODS.calculate_round_score() )})'''
position = 'after'
payload = '''
local nanny = tostring(number_format(math.floor(SMODS.calculate_round_score())))
print(nanny)
-- -nan fix
if nanny ~= '-nan' then
    G.GAME.round_scores['hand'].amt = math.max(G.GAME.round_scores['hand'].amt,SMODS.calculate_round_score())
else
    G.GAME.round_scores['hand'].amt = math.huge
end
local checker = G.GAME.blind:unik_debuff_after_hand(poker_hands, scoring_hand,G.play.cards,false,SMODS.calculate_round_score())
local debuff_hand = false
local add_to_blind = 0
if checker and checker.debuff then
    debuff_hand = true
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function()
            if SMODS.hand_debuff_source then SMODS.hand_debuff_source:juice_up(0.3,0) else SMODS.juice_up_blind() end
            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()
                play_sound('tarot2', 0.76, 0.4);return true end}))
            play_sound('tarot2', 1, 0.4)
            return true
        end)
    }))
end
if checker and checker.add_to_blind then
    if nanny == '-nan' then
        add_to_blind = to_big(math.huge)
    end
    add_to_blind = to_big(checker.add_to_blind)
end
'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''        func = (function() play_sound('chips2');return true end)
        }))
    end'''
position = 'after'
payload = '''
if to_big(add_to_blind) > to_big(0) then
    G.E_MANAGER:add_event(Event({
        trigger = 'after',
        func = (function() 
            G.GAME.blind.chips = G.GAME.blind.chips + add_to_blind
            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips + add_to_blind)
            G.HUD_blind:recalculate(true)
            G.hand_text_area.blind_chips:juice_up()
        
        return true end)
        }))
end
if debuff_hand then
    play_area_status_text("Not Allowed!")

    SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, debuffed_hand = true})
end

'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind, now with bunco compat.
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'before'
payload = '''
if not debuff_hand and nanny ~= '-nan' and G.GAME.chips_text ~= '-nan' then
'''

### display the fake score before not allowing the hand and/or adding to blind part 2
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'after'
payload = '''
elseif nanny == '-nan' or G.GAME.chips_text == '-nan' then
 G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = (function() 
                    G.GAME.chips = math.huge
                    G.GAME.blind:calculate()
                
                return true end)
                }))
    
end
'''

### unik_afterplay
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true})'''
position = 'after'
payload = '''
G.GAME.blind:unik_after_play()
'''
match_indent = true