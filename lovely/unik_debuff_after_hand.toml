[manifest]
version = "0.0.1"
dump_lua = true
priority = 9999

### Debuff after hand, either for blind functionality after a hand is played, add to blind size or outright having it not score.

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''check_for_unlock({type = 'chip_score', chips = math.floor( SMODS.calculate_round_score() )})'''
position = 'after'
payload = '''
local nanny = tostring(number_format(math.floor(SMODS.calculate_round_score())))

-- -nan fix
local undefTalisman = false
if nanny ~= '-nan' then

    G.GAME.round_scores['hand'].amt = math.max(G.GAME.round_scores['hand'].amt,SMODS.calculate_round_score())
else
    if UNIK.has_talisman() then
        undefTalisman = true
        G.GAME.round_scores['hand'].amt = 0
        G.GAME.round_scores.hand.amt = 0
        print("WHOOPS! -NAN detected. Setting hand score to 0")
    else
        G.GAME.round_scores['hand'].amt = math.huge
        G.GAME.round_scores.hand.amt = math.huge
        print("WHOOPS! -NAN detected. Setting hand score to naneinf")
    end
    
end
local checker = G.GAME.blind:unik_debuff_after_hand(poker_hands, scoring_hand,G.play.cards,false,SMODS.calculate_round_score())
local debuff_hand = false
local add_to_blind = 0
if (checker and checker.debuff) or undefTalisman then
    debuff_hand = true
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function()
            if SMODS.hand_debuff_source then SMODS.hand_debuff_source:juice_up(0.3,0) else SMODS.juice_up_blind() end
            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()
                play_sound('tarot2', 0.76, 0.4);return true end}))
            play_sound('tarot2', 1, 0.4)
            return true
        end)
    }))
end
if checker and checker.add_to_blind then
    if nanny == '-nan' then
        add_to_blind = math.huge
        if undefTalisman then
            add_to_blind = 0
        end
    else
        add_to_blind = to_big(checker.add_to_blind)
    end
    
end
'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''        func = (function() play_sound('chips2');return true end)
        }))
    end'''
position = 'after'
payload = '''
if to_big(add_to_blind) > to_big(0) or add_to_blind == math.huge then
G.E_MANAGER:add_event(Event({
    trigger = 'immediate',
    func = (function() 
    if add_to_blind == math.huge then
            G.GAME.blind.chips = math.huge
        G.GAME.blind.chip_text = number_format(math.huge)
        --G.HUD_blind:recalculate(true)
        G.hand_text_area.blind_chips:juice_up()
    else
        G.GAME.blind.chips = G.GAME.blind.chips + add_to_blind
        G.GAME.blind.chip_text = G.GAME.blind.chips
        --G.HUD_blind:recalculate(true)
        G.hand_text_area.blind_chips:juice_up()
    end
        

    return true end)
    }))
end


if debuff_hand and not undefTalisman then
    play_area_status_text("Not Allowed!")

    SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, debuffed_hand = true})
end
if undefTalisman then
    play_area_status_text("Score is undefined!")

    SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, debuffed_hand = true})
end

'''
match_indent = true

### display the fake score before not allowing the hand and/or adding to blind, now with bunco compat.
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'before'
payload = '''
if not debuff_hand and nanny ~= '-nan' and G.GAME.chips_text ~= '-nan' and not undefTalisman then
'''

### display the fake score before not allowing the hand and/or adding to blind part 2
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = '''G.E_MANAGER\:add_event\(Event\(\{
      trigger = 'ease',
      blocking = false,
      ref_table = G.GAME,
      ref_value = 'chips',
      ease_to = (.*),
      delay =  0.5,
      func = (.*)
    }\)\)'''
position = 'after'
payload = '''
elseif not debuff_hand and nanny == '-nan' or G.GAME.chips_text == '-nan' and not undefTalisman then
 G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = (function() 
                    G.GAME.chips = math.huge
                    G.GAME.blind:calculate()
                
                return true end)
                }))
    
end
'''

### unik_afterplay
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true})'''
position = 'after'
payload = '''
G.GAME.blind:unik_after_play()
if G.GAME.blind_edition and G.GAME.blind_edition[G.GAME.blind_on_deck] and not reset and (G.GAME.blind and G.GAME.blind.name and G.GAME.blind.name ~= '') then
    local edi = G.P_BLIND_EDITIONS[G.GAME.blind_edition[G.GAME.blind_on_deck]]
    if edi.unik_after_play and edi.unik_after_play() and (type(edi.unik_after_play) == "function") then
        delay(0.4)
        edi:unik_after_play()
    end
end
'''
match_indent = true

### unik_afterplay
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if G.GAME.chips - G.GAME.blind.chips >= 0 then'''
position = 'at'
payload = '''if to_big(G.GAME.chips - G.GAME.blind.chips) >= to_big(0) then'''
match_indent = true